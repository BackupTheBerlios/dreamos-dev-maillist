From finarfin at mail.berlios.de  Sun Jan  2 23:56:28 2011
From: finarfin at mail.berlios.de (finarfin at mail.berlios.de)
Date: Sun,  2 Jan 2011 23:56:28 +0100
Subject: [Dreamos-dev] r330 - in trunk: . mem
Message-ID: <20110102225628.9146948090C@sheep.berlios.de>

Author: finarfin
Date: 2011-01-02 23:56:28 +0100 (Sun, 02 Jan 2011)
New Revision: 330

Modified:
   trunk/dreamos.img
   trunk/mem/heap.c
Log:
Aggiunta unify_left e unify_right nella new_free.


Modified: trunk/dreamos.img
===================================================================
(Binary files differ)

Modified: trunk/mem/heap.c
===================================================================
--- trunk/mem/heap.c	2010-12-30 22:47:48 UTC (rev 329)
+++ trunk/mem/heap.c	2011-01-02 22:56:28 UTC (rev 330)
@@ -226,6 +226,31 @@
 	header->is_hole = HEAP_HOLE;
 	char to_add = 1;
 	/**Unify left*/
-	footer_t* test_f = (footer_t*) (unsigned int)(header - sizeof(footer_t));
-	/**TODO: unify left and unify right*/
+	/**Test if on the left i have a hole*/
+	footer_t* left_footer = (footer_t*) ((unsigned int) header - sizeof(footer_t));
+	if(left_footer->magic == HEAP_MAGIC && left_footer->header->is_hole == HEAP_HOLE){
+		printf("unify left\n");
+		/**I have found a hole on the left of my current header i need to save the size of
+		 * my current block*/
+		unsigned int cur_block_size = header->size;
+		/**Now i update my header pointer to the new hole found*/
+		header = left_footer->header;
+		header->size = header->size + cur_block_size;
+		/**Now i update the address of the header into footer*/
+		footer->header = header;
+		to_add = 0;
+	}
+	header_t* right_header = (header_t*) ((unsigned int)footer + sizeof(footer_t));
+	if(right_header->magic == HEAP_MAGIC && right_header->is_hole == HEAP_HOLE){
+		unsigned int i = 0;
+		printf("unify right\n");
+		/**First: update the size of the new header*/
+		header->size = header->size + right_header->size;
+		left_footer = (footer_t*) ((unsigned int) right_header + right_header->size - sizeof(footer_t));
+		footer = left_footer;
+		while((i < t_heap->index.size) && get_array(i, &t_heap->index) != (void_t*)right_header)			
+			i++;
+		if(i<t_heap->index.size) remove_array(i, &t_heap->index);		
+	}
+	
 }



From finarfin at mail.berlios.de  Tue Jan  4 23:27:30 2011
From: finarfin at mail.berlios.de (finarfin at mail.berlios.de)
Date: Tue,  4 Jan 2011 23:27:30 +0100
Subject: [Dreamos-dev] r331 - in trunk: . mem
Message-ID: <20110104222730.62935480553@sheep.berlios.de>

Author: finarfin
Date: 2011-01-04 23:27:30 +0100 (Tue, 04 Jan 2011)
New Revision: 331

Modified:
   trunk/dreamos.img
   trunk/mem/heap.c
Log:
Terminata new_free. 
Next steps: tests, e se tutto va bene la 0.3 si avvicina!!


Modified: trunk/dreamos.img
===================================================================
(Binary files differ)

Modified: trunk/mem/heap.c
===================================================================
--- trunk/mem/heap.c	2011-01-02 22:56:28 UTC (rev 330)
+++ trunk/mem/heap.c	2011-01-04 22:27:30 UTC (rev 331)
@@ -186,7 +186,7 @@
 }
 
 unsigned int contract(unsigned int new_size, new_heap_t *t_heap){
-	printf("PlaceHolder for new function contract\n");
+	//printf("PlaceHolder for new function contract\n");
 	if(new_size&0x1000){
         new_size &= 0x1000;
         new_size += 0x1000;
@@ -252,5 +252,25 @@
 			i++;
 		if(i<t_heap->index.size) remove_array(i, &t_heap->index);		
 	}
-	
+	/**We must check if we aren't at the end of memory*/
+	if(((unsigned int)footer + sizeof(footer_t)) == t_heap->end_address){
+		unsigned int old_size = t_heap->end_address - t_heap->start_address;
+		unsigned int new_size = contract((unsigned int)header - t_heap->start_address, t_heap);
+		/**We need to resize?*/
+		if(header->size - (old_size-new_size) > 0){
+			footer = (footer_t *) (unsigned int)header + header->size - sizeof(footer_t);
+			footer->magic = HEAP_MAGIC;
+			footer->header = header;
+		}
+		else {
+			unsigned int i = 0;
+			while(i<t_heap->index.size && get_array(i, &t_heap->index)!=(void_t*)right_header)
+				i++;
+			if(i < t_heap->index.size)
+				remove_array(i, &t_heap->index);
+		}
+	}
+	if(to_add == 1) {
+			insert_array((void_t*) header, &t_heap->index);
+	}	
 }



From finarfin at mail.berlios.de  Sun Jan  9 10:27:59 2011
From: finarfin at mail.berlios.de (finarfin at mail.berlios.de)
Date: Sun,  9 Jan 2011 10:27:59 +0100
Subject: [Dreamos-dev] r332 - in trunk: . boot utils utils/eltorito_iso
Message-ID: <20110109092759.6EBCC480A26@sheep.berlios.de>

Author: finarfin
Date: 2011-01-09 10:27:59 +0100 (Sun, 09 Jan 2011)
New Revision: 332

Modified:
   trunk/README
   trunk/boot/grub.img
   trunk/utils/eltorito_gen.sh
   trunk/utils/eltorito_iso/README
Log:
Aggiornati files readme. 
Sistemate alcune stringhe nello script eltorito_gen.sh


Modified: trunk/README
===================================================================
--- trunk/README	2011-01-04 22:27:30 UTC (rev 331)
+++ trunk/README	2011-01-09 09:27:59 UTC (rev 332)
@@ -26,12 +26,9 @@
 
 Ivan Gualandri - Finarfin (http://earyrian.elenhost.org)
 
-
 Alessandro (celeron) 
-Diego Stamigni (osiris_h4ck)
-Lorenzo De Liso (blackz)
-Michele Morelli (dt-)
 
+
 	- a -- Cosa NON ? DreamOS -
 
 DreamOS non ? un sistema operativo completo e pronto per essere utilizzato per l'uso quotidiano, non ? basato su Kernel esistenti e non ? supportato/sponsorizzato da alcuna societ?.
@@ -132,6 +129,6 @@
 	Chan: #dreamos
 	
 
-DreamOS 2003-2009 by finarfin/shainer
+DreamOS 2003-2011 by finarfin
 http://www.dreamos.org
 http://www.osdev.it

Modified: trunk/boot/grub.img
===================================================================
(Binary files differ)

Modified: trunk/utils/eltorito_gen.sh
===================================================================
--- trunk/utils/eltorito_gen.sh	2011-01-04 22:27:30 UTC (rev 331)
+++ trunk/utils/eltorito_gen.sh	2011-01-09 09:27:59 UTC (rev 332)
@@ -1,7 +1,7 @@
 #!/bin/bash
 # Script for build an eltorito iso image of dreamos
 
-echo "Welcome to DreamOS iso generator ver 0.1 - Development"
+echo "Welcome to DreamOS Eltorito iso generator ver 0.1 - Development"
 if [ -f dreamos.img ] 
 	then 
 		echo "File dreamos.img found"
@@ -11,7 +11,7 @@
 			echo "File initfs found: replacing it"
 			cp initfs ./utils/eltorito_iso
 		else
-			echo "file initfs not found"
+			echo "file initfs not found. Using the old one"
 		fi
 		 genisoimage -R -b boot/grub/stage2_eltorito -no-emul-boot -boot-load-size 4 -boot-info-table -o dreamos.iso utils/eltorito_iso
 	else

Modified: trunk/utils/eltorito_iso/README
===================================================================
--- trunk/utils/eltorito_iso/README	2011-01-04 22:27:30 UTC (rev 331)
+++ trunk/utils/eltorito_iso/README	2011-01-09 09:27:59 UTC (rev 332)
@@ -72,6 +72,6 @@
 	Chan: #dreamos
 	
 
-DreamOS 2003-2009 by finarfin/shainer
+DreamOS 2003-2011 by finarfin
 http://www.dreamos.org
 http://www.osdev.it



From finarfin at mail.berlios.de  Sun Jan  9 23:11:37 2011
From: finarfin at mail.berlios.de (finarfin at mail.berlios.de)
Date: Sun,  9 Jan 2011 23:11:37 +0100
Subject: [Dreamos-dev] r333 - in trunk: . shell
Message-ID: <20110109221138.19B07480BEC@sheep.berlios.de>

Author: finarfin
Date: 2011-01-09 23:11:37 +0100 (Sun, 09 Jan 2011)
New Revision: 333

Modified:
   trunk/dreamos.img
   trunk/shell/testing.c
Log:
Aggiornata la funzione che testa il nuovo gestore di memoria


Modified: trunk/dreamos.img
===================================================================
(Binary files differ)

Modified: trunk/shell/testing.c
===================================================================
--- trunk/shell/testing.c	2011-01-09 09:27:59 UTC (rev 332)
+++ trunk/shell/testing.c	2011-01-09 22:11:37 UTC (rev 333)
@@ -100,11 +100,26 @@
 }
 
 void try_newheap(){
+	unsigned int testA;
+	unsigned int testB;
+	unsigned int testC;
 	//printf("Testing the new heap (in development)\n");
 	//printf("First step: testing a new heap...\n");
 	//new_heap(HEAP_START_ADDRESS, HEAP_START_SIZE);
-	printf("Second step: trying new_malloc...\n");
-	new_malloc(sizeof(new_heap_t));	
+	printf("Second step: trying new_malloc...\n");	
+	testA=new_malloc(8);	
+	printf("Address of testA = 0x%x\n", testA);
+	testB=new_malloc(8);
+	printf("Address of testB = 0x%x\n", testB);
+	testC=new_malloc(8);
+	printf("Address of testC = 0x%x\n", testC);
+	new_free(testC);
+	new_free(testB);
+	unsigned int testD;
+	testD = new_malloc(12);
+	printf("Address of testD= 0x%x\n", testD);
+	new_free(testA);
+	new_free(testD);
 	printf("DONE\n");
 }
 



From finarfin at mail.berlios.de  Wed Jan 12 23:13:20 2011
From: finarfin at mail.berlios.de (finarfin at mail.berlios.de)
Date: Wed, 12 Jan 2011 23:13:20 +0100
Subject: [Dreamos-dev] r334 - trunk/io
Message-ID: <20110112221320.D798D480A0C@sheep.berlios.de>

Author: finarfin
Date: 2011-01-12 23:13:20 +0100 (Wed, 12 Jan 2011)
New Revision: 334

Modified:
   trunk/io/video.c
Log:
Fixed hex number conversion in string

Modified: trunk/io/video.c
===================================================================
--- trunk/io/video.c	2011-01-09 22:11:37 UTC (rev 333)
+++ trunk/io/video.c	2011-01-12 22:13:20 UTC (rev 334)
@@ -262,7 +262,7 @@
 void _kntohex (char *buffer, unsigned int decnum)
 {
   int shift=0;
-  int tempnum = decnum;
+  unsigned int tempnum = decnum;
 
   while (tempnum>=16) {
     tempnum >>= 4;



From finarfin at mail.berlios.de  Mon Jan 17 22:33:00 2011
From: finarfin at mail.berlios.de (finarfin at mail.berlios.de)
Date: Mon, 17 Jan 2011 22:33:00 +0100
Subject: [Dreamos-dev] r335 - in trunk: . boot include/mem libc mem shell
Message-ID: <20110117213300.4AA9948129D@sheep.berlios.de>

Author: finarfin
Date: 2011-01-17 22:32:59 +0100 (Mon, 17 Jan 2011)
New Revision: 335

Modified:
   trunk/bl.img
   trunk/boot/grub.img
   trunk/dreamos.img
   trunk/include/mem/heap.h
   trunk/kernel.c
   trunk/libc/stdio.c
   trunk/mem/heap.c
   trunk/shell/testing.c
Log:
Updated new_alloc


Modified: trunk/bl.img
===================================================================
(Binary files differ)

Modified: trunk/boot/grub.img
===================================================================
(Binary files differ)

Modified: trunk/dreamos.img
===================================================================
(Binary files differ)

Modified: trunk/include/mem/heap.h
===================================================================
--- trunk/include/mem/heap.h	2011-01-12 22:13:20 UTC (rev 334)
+++ trunk/include/mem/heap.h	2011-01-17 21:32:59 UTC (rev 335)
@@ -24,7 +24,7 @@
 #ifndef __HEAP_H
 #define __HEAP_H
 
-#define HEAP_START_ADDRESS 0xD0000000 /**Indirizzo iniziale*/
+#define HEAP_START_ADDRESS 0xC0000000 /**Indirizzo iniziale*/
 #define HEAP_START_SIZE 0x100000
 #define HEAP_INDEX_SIZE 0x20000
 #define HEAP_MIN_SIZE 0x70000
@@ -58,7 +58,7 @@
     \brief Contiene altre informazioni relative alle locazioni di memoria 
  */
 typedef struct {
-	int magic; /*!<For footer identification */
+	unsigned int magic; /*!<For footer identification */
 	header_t *header;/*!< Pointer to the block header*/
 } footer_t;
 

Modified: trunk/kernel.c
===================================================================
--- trunk/kernel.c	2011-01-12 22:13:20 UTC (rev 334)
+++ trunk/kernel.c	2011-01-17 21:32:59 UTC (rev 335)
@@ -98,10 +98,11 @@
     asm("sti");
     _kprintOK();   
     init_paging();
+
+    /*
     init_newmem();     
-    /*
     try_newheap();
-    while(1);
+    while(1);            
     */
     _kprintOK();    	
     printf("Memory (upper) amount-> %d Mb \n", boot_info->mem_upper/1024);

Modified: trunk/libc/stdio.c
===================================================================
--- trunk/libc/stdio.c	2011-01-12 22:13:20 UTC (rev 334)
+++ trunk/libc/stdio.c	2011-01-17 21:32:59 UTC (rev 335)
@@ -163,7 +163,7 @@
             }
             if (*format == 'x' || *format == 'X') {
                 int varhex = va_arg (ap, unsigned int);
-                _kntos (cur_p, varhex, 16);
+                _kntohex (cur_p, varhex);
             }
             if (*format == 'n')
                 _kntos (cur_p, len, 10);

Modified: trunk/mem/heap.c
===================================================================
--- trunk/mem/heap.c	2011-01-12 22:13:20 UTC (rev 334)
+++ trunk/mem/heap.c	2011-01-17 21:32:59 UTC (rev 335)
@@ -67,7 +67,7 @@
 	if(n_heap==0) {
 		//I have no heap defined, i continue to use address_cur.
 		unsigned int tmp;
-		printf("No heap defined starting %x...\n", address_cur);
+		//printf("No heap defined starting %x...\n", address_cur);
 		tmp = address_cur; 
 		address_cur += size;
 		printf("New address: %x\n", address_cur);
@@ -76,10 +76,10 @@
 	else {
 		//If i have a heap, then i have vm management enabled, and i can call alloc...
 		void* new_address = new_alloc(size, PAGE_ALIGNED, n_heap);	
-		printf("Heap defined\n");
-		printf("Start Address: %u End Address: %u\n", n_heap->start_address, n_heap->end_address);
-		printf("See address_cur value: %x\n", address_cur);
-		return 0;
+		//&printf("Heap defined\n");
+		printf("Start Address: %u End Address: %u ", n_heap->start_address, n_heap->end_address);
+		printf("Address_cur value: %x\n", address_cur);
+		return new_address;
 	}
 	return 0;
 }
@@ -87,23 +87,24 @@
 void *new_alloc(unsigned int size, unsigned short int p_aligned, new_heap_t* t_heap){
 	//#define MEMDEBUG 1
 	unsigned int real_size = size +sizeof(header_t) + sizeof(footer_t);	
-	printf("Size of:\n\theader_t: %d\n\tfooter_t: %d\n\treal_size: %d\n\tsize: %d\n", sizeof(header_t), sizeof(footer_t), real_size, size);	
+	//printf("Size of:\n\theader_t: %d\n\tfooter_t: %d\n\treal_size: %d\n\tsize: %d\n", sizeof(header_t), sizeof(footer_t), real_size, size);	
 	#ifdef  MEMDEBUG
+	printf("Real size: %d\n", real_size);
 	unsigned int min_index = locate_smallest_hole(real_size, PAGE_ALIGNED, t_heap);
 	if(min_index == -1 ){
 		/**No hole with the requested size found, asking more space for heap*/		
 		unsigned int old_len = t_heap->end_address - t_heap->start_address;		
 		unsigned int old_end_address = t_heap->end_address;			
 		/**expand the current heap*/
-		printf("Old len value: %d\n", old_len);
+		printf("Old len value: %d - ", old_len);
 		expand(old_len+real_size, t_heap);
-		unsigned int new_len = heap->end_address - heap->start_address;		
+		unsigned int new_len = t_heap->end_address - t_heap->start_address;		
 		printf("New len value: %d\n", old_len);		
 		min_index=0;
 		unsigned int latest_i = -1;
 		unsigned int val = 0x0;
 		/**Find the latest hole*/
-		while (min_index < heap->index.size){
+		while (min_index < t_heap->index.size){
 			unsigned int temp = get_array(min_index, &t_heap->index);
 			if(temp > val){
 				val = temp;
@@ -117,7 +118,7 @@
 			header->magic = HEAP_MAGIC;
 			header->size = new_len - old_len;
 			header->is_hole = HEAP_HOLE;
-			footer_t *footer  (footer_t *)(old_end_address + header->size - sizeof(footer_t));
+			footer_t *footer = (footer_t *)(old_end_address + header->size - sizeof(footer_t));
 			footer->magic = HEAP_MAGIC;
 			footer->header = header;
 			insert_array((void_t*)header, &t_heap->index);
@@ -131,34 +132,39 @@
 			footer->magic = HEAP_MAGIC;
 			footer->header = header;
 		}
+		printf("Recursing!!! \n");
 		return new_alloc(size, p_aligned, t_heap);
 	}
 	else {
 		header_t *header = get_array(min_index, &t_heap->index);
 		unsigned int hole_address = (unsigned int)header;
 		unsigned int hole_size = header->size;
-		printf("HOLE FOUND\n");
-		printf("In new_alloc: Header: 0x%x\tSize: 0x%x\n", header->magic, header->size);
+		//printf("HOLE FOUND\n");
+		printf("In new_alloc: Header: 0x%x\t Real Size: 0x%x\n", header->magic, real_size);
 		if(hole_size - real_size < sizeof(header_t) + sizeof(footer_t)){
 			/*We can't split the hole!*/
-			printf("A good step forward");
+			//printf("A good step forward");
 			size = hole_size + real_size;
 			real_size = hole_size;
 		}
-		//else remove_array(iterator, &t_heap->index);
+		else remove_array(min_index, &t_heap->index);
 		//Temporaneamente commentato!	
-		#ifdef DEBUG
+		//#ifdef DEBUG
 		header_t *block_header  = (header_t *)hole_address;
 		block_header->magic = HEAP_MAGIC;
-		block_header->size = real_size
+		block_header->size = real_size;
 		block_header->is_hole= HEAP_BLOCK;
-		#endif
+		footer_t *block_footer = (footer_t *)hole_address + size + sizeof(header_t);
+		block_footer->magic = HEAP_MAGIC;
+		block_footer->header = block_header;
+		printf("Block_header: %x - End of block_footer: %x\n", (unsigned int)block_header, (unsigned int)block_footer);
+		//#endif
 		if(hole_size - real_size >0){
 			/*We need to add a new hole. The new_hole address is given by:
 			 * the current hole address + size + sizeof(header_t) + sizeof(footer_t) 
-			 **/
-			printf("Add a new hole!\n");			
+			 **/			
 			header_t *head_hole = (header_t *)hole_address + sizeof(header_t) + size + sizeof(footer_t);
+			printf("Add a new hole! New address: %x\n", (unsigned int) head_hole);			
 			head_hole->magic = HEAP_MAGIC;
 			head_hole->is_hole = HEAP_HOLE;
 			head_hole->size = hole_size - real_size;
@@ -166,7 +172,7 @@
 			footer_hole->magic = HEAP_MAGIC;
 			footer_hole->header = head_hole;
 			insert_array((void *)head_hole, &t_heap->index);			
-		}
+		}	
 		return (block_header+sizeof(header_t));
 		//get_array(0, &t_heap->index);
 	}	
@@ -198,7 +204,7 @@
 
 short int locate_smallest_hole(unsigned int size, unsigned short int p_align, new_heap_t* in_heap){
 	unsigned int index = 0; 
-	printf("Size index: %d\n", in_heap->index.size);
+	//printf("Size index: %d\n", in_heap->index.size);
 	while(index < in_heap->index.size){
 		unsigned int h_size;
 		header_t *header = (header_t *)get_array(index, &in_heap->index);
@@ -214,10 +220,9 @@
 		return index;
 }
 
-void new_free(void *address, new_heap_t* t_heap){
-	printf("Placeholder for new_free\n");
+void new_free(void *address, new_heap_t* t_heap){	
 	if(address==0){
-		printf("DoNothing\n");
+		//printf("DoNothing\n");
 		return;
 	}
 	header_t* header = (header_t*)(address - sizeof(header_t));

Modified: trunk/shell/testing.c
===================================================================
--- trunk/shell/testing.c	2011-01-12 22:13:20 UTC (rev 334)
+++ trunk/shell/testing.c	2011-01-17 21:32:59 UTC (rev 335)
@@ -107,19 +107,20 @@
 	//printf("First step: testing a new heap...\n");
 	//new_heap(HEAP_START_ADDRESS, HEAP_START_SIZE);
 	printf("Second step: trying new_malloc...\n");	
-	testA=new_malloc(8);	
-	printf("Address of testA = 0x%x\n", testA);
-	testB=new_malloc(8);
-	printf("Address of testB = 0x%x\n", testB);
-	testC=new_malloc(8);
-	printf("Address of testC = 0x%x\n", testC);
-	new_free(testC);
+	testA=(unsigned int)new_malloc(8);	
+	printf("-Address of testA = %u - Hex: 0x%x\n", testA,testA);
+	testB=(unsigned int)new_malloc(8);
+	printf("-Address of testB = %u - Hex: 0x%x\n", testB, testB);
+	//printf("testB - testA = %u", testB - testA);
+	//testC=new_malloc(8);
+	//printf("-Address of testC = %u\n", testC);
+	//new_free(testC);
 	new_free(testB);
-	unsigned int testD;
-	testD = new_malloc(12);
-	printf("Address of testD= 0x%x\n", testD);
+	//unsigned int testD;
+	//testD = new_malloc(12);
+	//printf("-Address of testD= %u\n", testD);
 	new_free(testA);
-	new_free(testD);
+	//new_free(testD);
 	printf("DONE\n");
 }
 



From theking0 at mail.berlios.de  Mon Jan 17 23:07:15 2011
From: theking0 at mail.berlios.de (theking0 at mail.berlios.de)
Date: Mon, 17 Jan 2011 23:07:15 +0100
Subject: [Dreamos-dev] r336 - in trunk: mem shell
Message-ID: <20110117220715.BFE6F48129C@sheep.berlios.de>

Author: theking0
Date: 2011-01-17 23:07:15 +0100 (Mon, 17 Jan 2011)
New Revision: 336

Modified:
   trunk/mem/heap.c
   trunk/mem/paging.c
   trunk/shell/testing.c
Log:
Fix all compile warnings

Modified: trunk/mem/heap.c
===================================================================
--- trunk/mem/heap.c	2011-01-17 21:32:59 UTC (rev 335)
+++ trunk/mem/heap.c	2011-01-17 22:07:15 UTC (rev 336)
@@ -26,6 +26,7 @@
 #include <stdio.h>
 #include <ordered_array.h>
 #include <kheap.h>
+#include <stddef.h>
 
 extern unsigned int end;
 extern unsigned int address_cur;
@@ -79,16 +80,16 @@
 		//&printf("Heap defined\n");
 		printf("Start Address: %u End Address: %u ", n_heap->start_address, n_heap->end_address);
 		printf("Address_cur value: %x\n", address_cur);
-		return new_address;
+		return (unsigned int)new_address;
 	}
 	return 0;
 }
 
 void *new_alloc(unsigned int size, unsigned short int p_aligned, new_heap_t* t_heap){
 	//#define MEMDEBUG 1
+#ifdef  MEMDEBUG
 	unsigned int real_size = size +sizeof(header_t) + sizeof(footer_t);	
 	//printf("Size of:\n\theader_t: %d\n\tfooter_t: %d\n\treal_size: %d\n\tsize: %d\n", sizeof(header_t), sizeof(footer_t), real_size, size);	
-	#ifdef  MEMDEBUG
 	printf("Real size: %d\n", real_size);
 	unsigned int min_index = locate_smallest_hole(real_size, PAGE_ALIGNED, t_heap);
 	if(min_index == -1 ){
@@ -177,6 +178,7 @@
 		//get_array(0, &t_heap->index);
 	}	
 	#endif
+	return NULL;
 }
 
 void expand(unsigned int new_size, new_heap_t *t_heap){

Modified: trunk/mem/paging.c
===================================================================
--- trunk/mem/paging.c	2011-01-17 21:32:59 UTC (rev 335)
+++ trunk/mem/paging.c	2011-01-17 22:07:15 UTC (rev 336)
@@ -257,7 +257,7 @@
     if (pd_entry == 0) {
 	    int i=0;
 	    new_pt = create_pageTable();
-	    if(new_pt==4468736) printf("Eccolo qua lo stronzo\n");
+	    if(new_pt == (unsigned int *) 4468736) printf("Eccolo qua lo stronzo\n");
 	    while(i<PT_LIMIT){
 	      new_pt[i] = 0x00000000;
 	      i++;

Modified: trunk/shell/testing.c
===================================================================
--- trunk/shell/testing.c	2011-01-17 21:32:59 UTC (rev 335)
+++ trunk/shell/testing.c	2011-01-17 22:07:15 UTC (rev 336)
@@ -102,7 +102,7 @@
 void try_newheap(){
 	unsigned int testA;
 	unsigned int testB;
-	unsigned int testC;
+	//unsigned int testC;
 	//printf("Testing the new heap (in development)\n");
 	//printf("First step: testing a new heap...\n");
 	//new_heap(HEAP_START_ADDRESS, HEAP_START_SIZE);



From finarfin at mail.berlios.de  Mon Jan 17 23:23:42 2011
From: finarfin at mail.berlios.de (finarfin at mail.berlios.de)
Date: Mon, 17 Jan 2011 23:23:42 +0100
Subject: [Dreamos-dev] r337 - in trunk: . boot mem misc
Message-ID: <20110117222342.A015148129C@sheep.berlios.de>

Author: finarfin
Date: 2011-01-17 23:23:42 +0100 (Mon, 17 Jan 2011)
New Revision: 337

Modified:
   trunk/boot/grub.img
   trunk/dreamos.img
   trunk/mem/heap.c
   trunk/misc/ordered_array.c
Log:
Fixed hole creation


Modified: trunk/boot/grub.img
===================================================================
(Binary files differ)

Modified: trunk/dreamos.img
===================================================================
(Binary files differ)

Modified: trunk/mem/heap.c
===================================================================
--- trunk/mem/heap.c	2011-01-17 22:07:15 UTC (rev 336)
+++ trunk/mem/heap.c	2011-01-17 22:23:42 UTC (rev 337)
@@ -78,7 +78,7 @@
 		//If i have a heap, then i have vm management enabled, and i can call alloc...
 		void* new_address = new_alloc(size, PAGE_ALIGNED, n_heap);	
 		//&printf("Heap defined\n");
-		printf("Start Address: %u End Address: %u ", n_heap->start_address, n_heap->end_address);
+		printf("Start Address: %x End Address: %x ", n_heap->start_address, n_heap->end_address);
 		printf("Address_cur value: %x\n", address_cur);
 		return (unsigned int)new_address;
 	}
@@ -87,20 +87,21 @@
 
 void *new_alloc(unsigned int size, unsigned short int p_aligned, new_heap_t* t_heap){
 	//#define MEMDEBUG 1
-#ifdef  MEMDEBUG
+	#ifdef  MEMDEBUG
 	unsigned int real_size = size +sizeof(header_t) + sizeof(footer_t);	
 	//printf("Size of:\n\theader_t: %d\n\tfooter_t: %d\n\treal_size: %d\n\tsize: %d\n", sizeof(header_t), sizeof(footer_t), real_size, size);	
 	printf("Real size: %d\n", real_size);
 	unsigned int min_index = locate_smallest_hole(real_size, PAGE_ALIGNED, t_heap);
+	printf("Real size: %d - min_index: %d\n", real_size, min_index);
 	if(min_index == -1 ){
 		/**No hole with the requested size found, asking more space for heap*/		
 		unsigned int old_len = t_heap->end_address - t_heap->start_address;		
 		unsigned int old_end_address = t_heap->end_address;			
 		/**expand the current heap*/
-		printf("Old len value: %d - ", old_len);
+		printf("Old len value: %x - ", old_len);
 		expand(old_len+real_size, t_heap);
 		unsigned int new_len = t_heap->end_address - t_heap->start_address;		
-		printf("New len value: %d\n", old_len);		
+		printf("New len value: %x\n", old_len);		
 		min_index=0;
 		unsigned int latest_i = -1;
 		unsigned int val = 0x0;
@@ -141,12 +142,12 @@
 		unsigned int hole_address = (unsigned int)header;
 		unsigned int hole_size = header->size;
 		//printf("HOLE FOUND\n");
-		printf("In new_alloc: Header: 0x%x\t Real Size: 0x%x\n", header->magic, real_size);
+		printf(" In new_alloc: Header: 0x%x\t Real Size: 0x%x\n", header->magic, real_size);
 		if(hole_size - real_size < sizeof(header_t) + sizeof(footer_t)){
 			/*We can't split the hole!*/
 			//printf("A good step forward");
 			size = hole_size + real_size;
-			real_size = hole_size;
+			real_size = hole_size;			
 		}
 		else remove_array(min_index, &t_heap->index);
 		//Temporaneamente commentato!	
@@ -164,7 +165,7 @@
 			/*We need to add a new hole. The new_hole address is given by:
 			 * the current hole address + size + sizeof(header_t) + sizeof(footer_t) 
 			 **/			
-			header_t *head_hole = (header_t *)hole_address + sizeof(header_t) + size + sizeof(footer_t);
+			header_t *head_hole = (header_t *)(hole_address + sizeof(header_t) + size + sizeof(footer_t));
 			printf("Add a new hole! New address: %x\n", (unsigned int) head_hole);			
 			head_hole->magic = HEAP_MAGIC;
 			head_hole->is_hole = HEAP_HOLE;

Modified: trunk/misc/ordered_array.c
===================================================================
--- trunk/misc/ordered_array.c	2011-01-17 22:07:15 UTC (rev 336)
+++ trunk/misc/ordered_array.c	2011-01-17 22:23:42 UTC (rev 337)
@@ -108,7 +108,7 @@
   */
 type_t get_array(int index, ordered_array_t* t_array){
 	if(index < t_array->size){
-		printf("Value: %u", (type_t*)t_array->array[0]);
+		printf("Value: %x ", (type_t*)t_array->array[index]);
 		return t_array->array[index];
 	}
 	else {		
@@ -136,7 +136,7 @@
 void print_array(ordered_array_t* array){
 	int i=0;	
 	while(i<array->size){
-		printf("Val: %d: %u\n", i, array->array[i]);
+		printf("Val: %d: %x\n", i, array->array[i]);
 		i++;
 	}
 }



From finarfin at mail.berlios.de  Tue Jan 18 23:12:02 2011
From: finarfin at mail.berlios.de (finarfin at mail.berlios.de)
Date: Tue, 18 Jan 2011 23:12:02 +0100
Subject: [Dreamos-dev] r338 - in trunk: . boot mem misc shell
Message-ID: <20110118221203.08F2F4812A3@sheep.berlios.de>

Author: finarfin
Date: 2011-01-18 23:12:02 +0100 (Tue, 18 Jan 2011)
New Revision: 338

Modified:
   trunk/boot/grub.img
   trunk/dreamos.img
   trunk/mem/heap.c
   trunk/misc/ordered_array.c
   trunk/shell/testing.c
Log:
Fixed new_alloc e new_free.


Modified: trunk/boot/grub.img
===================================================================
(Binary files differ)

Modified: trunk/dreamos.img
===================================================================
(Binary files differ)

Modified: trunk/mem/heap.c
===================================================================
--- trunk/mem/heap.c	2011-01-17 22:23:42 UTC (rev 337)
+++ trunk/mem/heap.c	2011-01-18 22:12:02 UTC (rev 338)
@@ -78,8 +78,8 @@
 		//If i have a heap, then i have vm management enabled, and i can call alloc...
 		void* new_address = new_alloc(size, PAGE_ALIGNED, n_heap);	
 		//&printf("Heap defined\n");
-		printf("Start Address: %x End Address: %x ", n_heap->start_address, n_heap->end_address);
-		printf("Address_cur value: %x\n", address_cur);
+		printf("Start Address: %x End Address: %x\n", n_heap->start_address, n_heap->end_address);
+		//printf("Address_cur value: %x\n", address_cur);
 		return (unsigned int)new_address;
 	}
 	return 0;
@@ -156,7 +156,7 @@
 		block_header->magic = HEAP_MAGIC;
 		block_header->size = real_size;
 		block_header->is_hole= HEAP_BLOCK;
-		footer_t *block_footer = (footer_t *)hole_address + size + sizeof(header_t);
+		footer_t *block_footer = (footer_t *)(hole_address + size + sizeof(header_t));
 		block_footer->magic = HEAP_MAGIC;
 		block_footer->header = block_header;
 		printf("Block_header: %x - End of block_footer: %x\n", (unsigned int)block_header, (unsigned int)block_footer);
@@ -175,7 +175,7 @@
 			footer_hole->header = head_hole;
 			insert_array((void *)head_hole, &t_heap->index);			
 		}	
-		return (block_header+sizeof(header_t));
+		return (void *)((unsigned int)block_header+sizeof(header_t));
 		//get_array(0, &t_heap->index);
 	}	
 	#endif
@@ -228,14 +228,15 @@
 		//printf("DoNothing\n");
 		return;
 	}
-	header_t* header = (header_t*)(address - sizeof(header_t));
-	footer_t* footer = (footer_t*)(address + header->size - sizeof(footer_t));
+	header_t* header = (header_t*)((unsigned int)address - sizeof(header_t));	
+	footer_t* footer = (footer_t*)((unsigned int)header + header->size - sizeof(footer_t));	
 	/**Set header as a hole*/
 	header->is_hole = HEAP_HOLE;
 	char to_add = 1;
 	/**Unify left*/
 	/**Test if on the left i have a hole*/
 	footer_t* left_footer = (footer_t*) ((unsigned int) header - sizeof(footer_t));
+	printf("Address of header: %x - Footer: %x Left: %x\n", header, footer, footer->magic);
 	if(left_footer->magic == HEAP_MAGIC && left_footer->header->is_hole == HEAP_HOLE){
 		printf("unify left\n");
 		/**I have found a hole on the left of my current header i need to save the size of
@@ -265,6 +266,7 @@
 		unsigned int old_size = t_heap->end_address - t_heap->start_address;
 		unsigned int new_size = contract((unsigned int)header - t_heap->start_address, t_heap);
 		/**We need to resize?*/
+		printf("Test\n");
 		if(header->size - (old_size-new_size) > 0){
 			footer = (footer_t *) (unsigned int)header + header->size - sizeof(footer_t);
 			footer->magic = HEAP_MAGIC;
@@ -279,6 +281,7 @@
 		}
 	}
 	if(to_add == 1) {
+		printf("And then\n");
 			insert_array((void_t*) header, &t_heap->index);
 	}	
 }

Modified: trunk/misc/ordered_array.c
===================================================================
--- trunk/misc/ordered_array.c	2011-01-17 22:23:42 UTC (rev 337)
+++ trunk/misc/ordered_array.c	2011-01-18 22:12:02 UTC (rev 338)
@@ -112,7 +112,7 @@
 		return t_array->array[index];
 	}
 	else {		
-		printf("PANIC");
+		printf("get_array: PANIC");
 		while(1);
 	}
 }

Modified: trunk/shell/testing.c
===================================================================
--- trunk/shell/testing.c	2011-01-17 22:23:42 UTC (rev 337)
+++ trunk/shell/testing.c	2011-01-18 22:12:02 UTC (rev 338)
@@ -108,19 +108,19 @@
 	//new_heap(HEAP_START_ADDRESS, HEAP_START_SIZE);
 	printf("Second step: trying new_malloc...\n");	
 	testA=(unsigned int)new_malloc(8);	
-	printf("-Address of testA = %u - Hex: 0x%x\n", testA,testA);
+	printf("-Address of testA Hex: 0x%x\n", testA);
 	testB=(unsigned int)new_malloc(8);
-	printf("-Address of testB = %u - Hex: 0x%x\n", testB, testB);
+	printf("-Address of testB Hex: 0x%x\n", testB);
 	//printf("testB - testA = %u", testB - testA);
 	//testC=new_malloc(8);
 	//printf("-Address of testC = %u\n", testC);
 	//new_free(testC);
 	new_free(testB);
-	//unsigned int testD;
-	//testD = new_malloc(12);
-	//printf("-Address of testD= %u\n", testD);
+	unsigned int testD;
+	testD = new_malloc(12);
+	printf("-Address of testD Hex: %x\n", testD);
 	new_free(testA);
-	//new_free(testD);
+	new_free(testD);
 	printf("DONE\n");
 }
 



From theking0 at mail.berlios.de  Fri Jan 21 00:30:57 2011
From: theking0 at mail.berlios.de (theking0 at mail.berlios.de)
Date: Fri, 21 Jan 2011 00:30:57 +0100
Subject: [Dreamos-dev] r339 - trunk/utils
Message-ID: <20110120233057.CDDDC4810A7@sheep.berlios.de>

Author: theking0
Date: 2011-01-21 00:30:57 +0100 (Fri, 21 Jan 2011)
New Revision: 339

Modified:
   trunk/utils/passwd.pl
Log:
modificato passwd.pl

Modified: trunk/utils/passwd.pl
===================================================================
--- trunk/utils/passwd.pl	2011-01-18 22:12:02 UTC (rev 338)
+++ trunk/utils/passwd.pl	2011-01-20 23:30:57 UTC (rev 339)
@@ -7,12 +7,26 @@
 # 2. flags.
 # 3. pulizia generale dello script.
 
-my $__script_version__="0.1";
+my $__script_version__="1.0.2";
 my $__script_author__="DT";
 my $__script_license__="New BSD License";
 
 my $filepath;
 
+if (@ARGV == 1) {
+	my $usage = "Usage: $0 [arguments]\n\t--version\n\t--help\n";
+	if($ARGV[0] eq "--version") {
+		print "Version: $__script_version__\n";
+		exit;
+	} elsif ($ARGV[0] eq "--help") {
+		print $usage;
+		exit;
+	} else {
+		print "Command not found!\n$usage";
+		exit;
+	}
+}
+
 if (-e &Cwd::realpath("../files/passwd")) {
 	$filepath=&Cwd::realpath("../files/passwd");
 } elsif (-e "files/passwd") {
@@ -43,9 +57,9 @@
 # Add User
 
 print "username: ";
-$username = <>;
+$username = <STDIN>;
 chomp($username);
-print "$username\n";
+#print "$username\n";
 
 if(!($username =~ m/^(\w+)$/)) {
 	print "Invalid username \"$username\"\n";
@@ -60,7 +74,7 @@
 
 print "password: ";
 system("stty -echo");
-$password = <>;
+$password = <STDIN>;
 system("stty echo");
 chomp($password);
 print "$password\n";
@@ -69,4 +83,4 @@
 
 print PASSWD "$username:$password\n";
 
-close(PASSWD);
\ No newline at end of file
+close(PASSWD);



From finarfin at mail.berlios.de  Sat Jan 22 09:59:01 2011
From: finarfin at mail.berlios.de (finarfin at mail.berlios.de)
Date: Sat, 22 Jan 2011 09:59:01 +0100
Subject: [Dreamos-dev] r340 - in trunk: . boot mem misc shell
Message-ID: <20110122085901.C15C64809B2@sheep.berlios.de>

Author: finarfin
Date: 2011-01-22 09:59:01 +0100 (Sat, 22 Jan 2011)
New Revision: 340

Modified:
   trunk/boot/grub.img
   trunk/dreamos.img
   trunk/mem/heap.c
   trunk/misc/ordered_array.c
   trunk/shell/testing.c
Log:
Removed some debug printf.
Updated new memory manager tests.
Remember: the new memory manager is still disabled. 


Modified: trunk/boot/grub.img
===================================================================
(Binary files differ)

Modified: trunk/dreamos.img
===================================================================
(Binary files differ)

Modified: trunk/mem/heap.c
===================================================================
--- trunk/mem/heap.c	2011-01-20 23:30:57 UTC (rev 339)
+++ trunk/mem/heap.c	2011-01-22 08:59:01 UTC (rev 340)
@@ -77,7 +77,7 @@
 	else {
 		//If i have a heap, then i have vm management enabled, and i can call alloc...
 		void* new_address = new_alloc(size, PAGE_ALIGNED, n_heap);	
-		//&printf("Heap defined\n");
+		//printf("Heap defined\n");
 		printf("Start Address: %x End Address: %x\n", n_heap->start_address, n_heap->end_address);
 		//printf("Address_cur value: %x\n", address_cur);
 		return (unsigned int)new_address;
@@ -90,18 +90,18 @@
 	#ifdef  MEMDEBUG
 	unsigned int real_size = size +sizeof(header_t) + sizeof(footer_t);	
 	//printf("Size of:\n\theader_t: %d\n\tfooter_t: %d\n\treal_size: %d\n\tsize: %d\n", sizeof(header_t), sizeof(footer_t), real_size, size);	
-	printf("Real size: %d\n", real_size);
+	//printf("Real size: %d\n", real_size);
 	unsigned int min_index = locate_smallest_hole(real_size, PAGE_ALIGNED, t_heap);
-	printf("Real size: %d - min_index: %d\n", real_size, min_index);
+	//printf("Real size: %d - min_index: %d\n", real_size, min_index);
 	if(min_index == -1 ){
 		/**No hole with the requested size found, asking more space for heap*/		
 		unsigned int old_len = t_heap->end_address - t_heap->start_address;		
 		unsigned int old_end_address = t_heap->end_address;			
 		/**expand the current heap*/
-		printf("Old len value: %x - ", old_len);
+		//printf("Old len value: %x - ", old_len);
 		expand(old_len+real_size, t_heap);
 		unsigned int new_len = t_heap->end_address - t_heap->start_address;		
-		printf("New len value: %x\n", old_len);		
+		//printf("New len value: %x\n", old_len);		
 		min_index=0;
 		unsigned int latest_i = -1;
 		unsigned int val = 0x0;
@@ -134,7 +134,7 @@
 			footer->magic = HEAP_MAGIC;
 			footer->header = header;
 		}
-		printf("Recursing!!! \n");
+		//printf("Recursing!!! \n");
 		return new_alloc(size, p_aligned, t_heap);
 	}
 	else {
@@ -142,7 +142,7 @@
 		unsigned int hole_address = (unsigned int)header;
 		unsigned int hole_size = header->size;
 		//printf("HOLE FOUND\n");
-		printf(" In new_alloc: Header: 0x%x\t Real Size: 0x%x\n", header->magic, real_size);
+		//printf(" In new_alloc: Header: 0x%x\t Real Size: 0x%x\n", header->magic, real_size);
 		if(hole_size - real_size < sizeof(header_t) + sizeof(footer_t)){
 			/*We can't split the hole!*/
 			//printf("A good step forward");
@@ -159,14 +159,14 @@
 		footer_t *block_footer = (footer_t *)(hole_address + size + sizeof(header_t));
 		block_footer->magic = HEAP_MAGIC;
 		block_footer->header = block_header;
-		printf("Block_header: %x - End of block_footer: %x\n", (unsigned int)block_header, (unsigned int)block_footer);
+		//printf("Block_header: %x - End of block_footer: %x\n", (unsigned int)block_header, (unsigned int)block_footer);
 		//#endif
 		if(hole_size - real_size >0){
 			/*We need to add a new hole. The new_hole address is given by:
 			 * the current hole address + size + sizeof(header_t) + sizeof(footer_t) 
 			 **/			
 			header_t *head_hole = (header_t *)(hole_address + sizeof(header_t) + size + sizeof(footer_t));
-			printf("Add a new hole! New address: %x\n", (unsigned int) head_hole);			
+			//printf("Add a new hole! New address: %x\n", (unsigned int) head_hole);			
 			head_hole->magic = HEAP_MAGIC;
 			head_hole->is_hole = HEAP_HOLE;
 			head_hole->size = hole_size - real_size;
@@ -236,9 +236,9 @@
 	/**Unify left*/
 	/**Test if on the left i have a hole*/
 	footer_t* left_footer = (footer_t*) ((unsigned int) header - sizeof(footer_t));
-	printf("Address of header: %x - Footer: %x Left: %x\n", header, footer, footer->magic);
+	//printf("Address of header: %x - Footer: %x Left: %x\n", header, footer, footer->magic);
 	if(left_footer->magic == HEAP_MAGIC && left_footer->header->is_hole == HEAP_HOLE){
-		printf("unify left\n");
+		//printf("unify left\n");
 		/**I have found a hole on the left of my current header i need to save the size of
 		 * my current block*/
 		unsigned int cur_block_size = header->size;
@@ -252,7 +252,7 @@
 	header_t* right_header = (header_t*) ((unsigned int)footer + sizeof(footer_t));
 	if(right_header->magic == HEAP_MAGIC && right_header->is_hole == HEAP_HOLE){
 		unsigned int i = 0;
-		printf("unify right\n");
+		//printf("unify right\n");
 		/**First: update the size of the new header*/
 		header->size = header->size + right_header->size;
 		left_footer = (footer_t*) ((unsigned int) right_header + right_header->size - sizeof(footer_t));
@@ -266,7 +266,7 @@
 		unsigned int old_size = t_heap->end_address - t_heap->start_address;
 		unsigned int new_size = contract((unsigned int)header - t_heap->start_address, t_heap);
 		/**We need to resize?*/
-		printf("Test\n");
+		//printf("Test\n");
 		if(header->size - (old_size-new_size) > 0){
 			footer = (footer_t *) (unsigned int)header + header->size - sizeof(footer_t);
 			footer->magic = HEAP_MAGIC;
@@ -281,7 +281,7 @@
 		}
 	}
 	if(to_add == 1) {
-		printf("And then\n");
+		//printf("And then\n");
 			insert_array((void_t*) header, &t_heap->index);
 	}	
 }

Modified: trunk/misc/ordered_array.c
===================================================================
--- trunk/misc/ordered_array.c	2011-01-20 23:30:57 UTC (rev 339)
+++ trunk/misc/ordered_array.c	2011-01-22 08:59:01 UTC (rev 340)
@@ -96,7 +96,7 @@
 		}
 		t_array->size++;
 	}    
-    print_array(t_array);
+    //print_array(t_array);
 }
 /**
   * Get an element from ordered_array
@@ -108,7 +108,7 @@
   */
 type_t get_array(int index, ordered_array_t* t_array){
 	if(index < t_array->size){
-		printf("Value: %x ", (type_t*)t_array->array[index]);
+		//printf("Value: %x ", (type_t*)t_array->array[index]);
 		return t_array->array[index];
 	}
 	else {		
@@ -136,7 +136,7 @@
 void print_array(ordered_array_t* array){
 	int i=0;	
 	while(i<array->size){
-		printf("Val: %d: %x\n", i, array->array[i]);
+		//printf("Val: %d: %x\n", i, array->array[i]);
 		i++;
 	}
 }

Modified: trunk/shell/testing.c
===================================================================
--- trunk/shell/testing.c	2011-01-20 23:30:57 UTC (rev 339)
+++ trunk/shell/testing.c	2011-01-22 08:59:01 UTC (rev 340)
@@ -102,7 +102,7 @@
 void try_newheap(){
 	unsigned int testA;
 	unsigned int testB;
-	//unsigned int testC;
+	unsigned int testC;
 	//printf("Testing the new heap (in development)\n");
 	//printf("First step: testing a new heap...\n");
 	//new_heap(HEAP_START_ADDRESS, HEAP_START_SIZE);
@@ -112,13 +112,13 @@
 	testB=(unsigned int)new_malloc(8);
 	printf("-Address of testB Hex: 0x%x\n", testB);
 	//printf("testB - testA = %u", testB - testA);
-	//testC=new_malloc(8);
-	//printf("-Address of testC = %u\n", testC);
-	//new_free(testC);
+	testC=new_malloc(8);
+	printf("-Address of testC Hex: 0x%x\n", testC);
+	new_free(testC);
 	new_free(testB);
 	unsigned int testD;
 	testD = new_malloc(12);
-	printf("-Address of testD Hex: %x\n", testD);
+	printf("-Address of testD Hex: 0x%x\n", testD);
 	new_free(testA);
 	new_free(testD);
 	printf("DONE\n");



From finarfin at mail.berlios.de  Sun Jan 23 23:27:23 2011
From: finarfin at mail.berlios.de (finarfin at mail.berlios.de)
Date: Sun, 23 Jan 2011 23:27:23 +0100
Subject: [Dreamos-dev] r341 - in trunk: . boot include/mem mem
Message-ID: <20110123222723.A280D4812E1@sheep.berlios.de>

Author: finarfin
Date: 2011-01-23 23:27:23 +0100 (Sun, 23 Jan 2011)
New Revision: 341

Modified:
   trunk/README
   trunk/boot/grub.img
   trunk/dreamos.img
   trunk/include/mem/heap.h
   trunk/include/mem/kheap.h
   trunk/mem/heap.c
Log:
Updated readme
Updated kheap.c


Modified: trunk/README
===================================================================
--- trunk/README	2011-01-22 08:59:01 UTC (rev 340)
+++ trunk/README	2011-01-23 22:27:23 UTC (rev 341)
@@ -24,8 +24,9 @@
 Il DreamOS ? un sistema operativo open source rilasciato sotto licenza GPLv3 sviluppato partendo da 0 puramente per scopi didattici o comunque per capire come funzionano i sistemi operativi.
 Il team di sviluppo attuale ? composto dagli sviluppatori
 
-Ivan Gualandri - Finarfin (http://earyrian.elenhost.org)
+Ivan Gualandri - Finarfin (http://www.osdev.it http://italialinux.altervista.org) - Creatore e Main Developer 
 
+Finessi Manuel (tk0)
 Alessandro (celeron) 
 
 

Modified: trunk/boot/grub.img
===================================================================
(Binary files differ)

Modified: trunk/dreamos.img
===================================================================
(Binary files differ)

Modified: trunk/include/mem/heap.h
===================================================================
--- trunk/include/mem/heap.h	2011-01-22 08:59:01 UTC (rev 340)
+++ trunk/include/mem/heap.h	2011-01-23 22:27:23 UTC (rev 341)
@@ -74,4 +74,10 @@
 unsigned int contract(unsigned int, new_heap_t*);
 short int locate_smallest_hole(unsigned int, unsigned short int, new_heap_t*);
 short int header_t_less_than(void *,void *);
+
+#ifdef OLD_MEM_DISABLED
+void* kmalloc(unsigned int);
+void kfree(unsigned int);
 #endif
+
+#endif

Modified: trunk/include/mem/kheap.h
===================================================================
--- trunk/include/mem/kheap.h	2011-01-22 08:59:01 UTC (rev 340)
+++ trunk/include/mem/kheap.h	2011-01-23 22:27:23 UTC (rev 341)
@@ -50,7 +50,7 @@
 
 heap_t* make_heap(unsigned int);
 void* kmalloc(unsigned int);
-void kfree(unsigned int);
+//void kfree(unsigned int);
 void try_alloc();
 heap_node_t* alloc_node();
 void free_node(heap_node_t*);

Modified: trunk/mem/heap.c
===================================================================
--- trunk/mem/heap.c	2011-01-22 08:59:01 UTC (rev 340)
+++ trunk/mem/heap.c	2011-01-23 22:27:23 UTC (rev 341)
@@ -162,9 +162,9 @@
 		//printf("Block_header: %x - End of block_footer: %x\n", (unsigned int)block_header, (unsigned int)block_footer);
 		//#endif
 		if(hole_size - real_size >0){
-			/*We need to add a new hole. The new_hole address is given by:
+			/**We need to add a new hole. The new_hole address is given by:
 			 * the current hole address + size + sizeof(header_t) + sizeof(footer_t) 
-			 **/			
+			 */			
 			header_t *head_hole = (header_t *)(hole_address + sizeof(header_t) + size + sizeof(footer_t));
 			//printf("Add a new hole! New address: %x\n", (unsigned int) head_hole);			
 			head_hole->magic = HEAP_MAGIC;



From finarfin at mail.berlios.de  Tue Jan 25 23:18:08 2011
From: finarfin at mail.berlios.de (finarfin at mail.berlios.de)
Date: Tue, 25 Jan 2011 23:18:08 +0100
Subject: [Dreamos-dev] r342 - in trunk: . drivers include/mem mem
Message-ID: <20110125221808.903A4480BFF@sheep.berlios.de>

Author: finarfin
Date: 2011-01-25 23:18:08 +0100 (Tue, 25 Jan 2011)
New Revision: 342

Modified:
   trunk/drivers/keyboard.c
   trunk/include/mem/heap.h
   trunk/kernel.c
   trunk/mem/heap.c
Log:
Sistemati alcuni commenti doxygen. 
Modifiche minori.


Modified: trunk/drivers/keyboard.c
===================================================================
--- trunk/drivers/keyboard.c	2011-01-23 22:27:23 UTC (rev 341)
+++ trunk/drivers/keyboard.c	2011-01-25 22:18:08 UTC (rev 342)
@@ -308,13 +308,26 @@
     return c;
 }
 
+/**
+  * Set Keyboard echo Shadow 
+  * @author Ivan Gualandri
+  * @version 1.0
+  * @param 1 if you want enable shadow 0 otherwise
+  * @return 1 if keyboard echo shadow enable 0 if not.
+  */
 int  set_shadow(int value){
 	if(value>1 || value < 0) return -1;
 	else shadow = value;
 	return shadow;
 }
 
-int get_shadow(){
-	//printf("Address shadow: %u\n", &shadow);
+/**
+  * Get Keyboard Shadow informations 
+  * @author Ivan Gualandri
+  * @version 1.0
+  * @return 1 if keyboard echo shadow enable 0 if not.
+  */
+
+int get_shadow(){	
 	return shadow;
 }

Modified: trunk/include/mem/heap.h
===================================================================
--- trunk/include/mem/heap.h	2011-01-23 22:27:23 UTC (rev 341)
+++ trunk/include/mem/heap.h	2011-01-25 22:18:08 UTC (rev 342)
@@ -49,16 +49,16 @@
     \brief Contiene le informazioni relative alle locazioni di memoria 
  */
 typedef struct {
-	unsigned int magic; /*!<For header identification*/	
-	short int is_hole; /*!<1 se si tratta di un hole 0 se si tratta di un block*/
-	int size;  /*!<Total size of the block (IMPORTANT: including header and footer)*/
+	unsigned int magic; /*!< For header identification*/	
+	short int is_hole; /*!< 1 se si tratta di un hole 0 se si tratta di un block*/
+	int size;  /*!< Total size of the block (IMPORTANT: including header and footer)*/
 }__attribute__((packed)) header_t;
 
 /*! \struct footer_t 
     \brief Contiene altre informazioni relative alle locazioni di memoria 
  */
 typedef struct {
-	unsigned int magic; /*!<For footer identification */
+	unsigned int magic; /*!< For footer identification */
 	header_t *header;/*!< Pointer to the block header*/
 } footer_t;
 

Modified: trunk/kernel.c
===================================================================
--- trunk/kernel.c	2011-01-23 22:27:23 UTC (rev 341)
+++ trunk/kernel.c	2011-01-25 22:18:08 UTC (rev 342)
@@ -107,7 +107,7 @@
     _kprintOK();    	
     printf("Memory (upper) amount-> %d Mb \n", boot_info->mem_upper/1024);
     printf("Memory (lower) amount-> %d kb \n", boot_info->mem_lower);	
-    /* Alloc and fill CPUID structure */
+    /** Alloc and fill CPUID structure */
     sinfo = kmalloc(sizeof(struct cpuinfo_generic));    
     get_cpuid (sinfo);        
     vfs_init();

Modified: trunk/mem/heap.c
===================================================================
--- trunk/mem/heap.c	2011-01-23 22:27:23 UTC (rev 341)
+++ trunk/mem/heap.c	2011-01-25 22:18:08 UTC (rev 342)
@@ -43,7 +43,6 @@
 }
 
 new_heap_t *new_heap(unsigned int start, unsigned int size){
-	/*Actually we need to use kmalloc!*/
 	new_heap_t* t_heap =(new_heap_t*) new_malloc(sizeof(new_heap_t));		
 	if(start%0x1000 == 0){		
 		header_t *first_hole = (header_t*)start;		
@@ -53,7 +52,7 @@
 		t_heap->max_address = 0xDFFFF000; /**Da controllare max address*/					
 		first_hole->size = t_heap->end_address - start;		
 		first_hole->magic = HEAP_MAGIC;		
-		first_hole->is_hole = 1; /*TRUE*/			
+		first_hole->is_hole = HEAP_HOLE; 
 		insert_array((void*) first_hole, &t_heap->index);
 		//printf("First hole: %u size: %u", t_heap->start_address, t_heap->end_address);
 		//get_array(0, &t_heap->index);



